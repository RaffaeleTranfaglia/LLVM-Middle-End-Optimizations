# Constant progation

The objective of constant propagation is to determine if variables take a constant value at any point of a function. A variable takes a constant value CONST at point p if it is guaranteed that every time that the execution reaches point p the variable has value CONST.

<br>
<b>Framework</b>

Parameters | Value
--- | ---
Domain | all couples (var, const_val)
Direction | forward <br> out[B] = F<sub>B</sub>(in[B]) <br> in[B] = ∧(out[predecessorB])
Transfer function (F) | F<sub>B</sub>(in[B]) = Gen<sub>B</sub> ∪ (in[B] - Kill<sub>B</sub>) <br> Gen<sub>B</sub> and Kill<sub>B</sub> must be <b>determined at every iteration</b> by analyzing the instructions of the block B in descending order* <br> out[inst] = F<sub>inst</sub>(in[inst]) = Gen<sub>inst</sub> ∪ (in[inst] - Kill<sub>inst</sub>) <br> where <br> Gen<sub>inst</sub> = (defined_var, const_val) if the right hand side can be considered constant ** <br> in[inst] are the couples propagated by the preceding instruction and in[inst] = in[B] for the first instruction of the block <br>  Kill<sub>inst</sub> = (defined_var, CONST), "CONST" staying for any constant value
Meet operator (∧) | ∩
Boundary condition | out[entry] = ∅
Initial interior points | out[B] = U


<br>Observations
- (*) Gen<sub>B</sub> and Kill<sub>B</sub> are determined by analyzing the instructions of the block B in descending order: the generated couples are the locally available definitions of all the variables where the right hand side is a constant or can be considered constant considering all couples that have been generated or propagated by the preceding instruction or block (in case of the first instruction of the current block); to determine the killed couples it must be considered that any definition of a variable kills all the other couples that have generated or propagated by the previous instruction or block.
- (**) the right hand side can be considered constant, which means it is an expression that only contains constants or variables that are contained in the couples propagated by the preceding instruction or block.
- It must be stressed what has been implied in the preceding note: the right hand side of a definition can be costant even if it contains other variables, provided that these ones can be considered constant; this means that the definition adds an entry to the Gen set calculated for the block depending on the couples generated or propagated by the preceding instruction or block. This marks a difference with the optimization tasks analyzed thus far: while in a generic task the Gen set and the Kill set could be determined staically on the code before executing the algorithm, in this case <b>the Gen set and the Kill set must be determined dinamically</b>.

<b><br>Pseudocode</b>
```
input = Control Flow Graph CFG (Nodes, Edges, Entry, Exit)

// Domain determination
Domain = ∅
for all variables x defined in the entire function, add (x,CONST) to Domain

// Boundary condition
out[Entry] = ∅

// Initialization
for each basic block B except Entry
    out[B] = Universe

// Iteration
while (changes to any out[] occour)
{
    for each basic block B other than Entry
    {
        in[B] = ∩(out[p]) for all predecessors p of B
        out[B] = F_B(in[B])
    }
}
```


<br>Observations
- Since a variable with a constant value can be used to define another variable, the latter can become a variable with a constant value as well. As a consequence, the domain is not easily fully determined at the beginning, with a statical analysis of the whole code; for this reason, it has been chosen to initialize it with a single couple for any variable present in the code, using a placeholder for a generic constant value, CONST. This "special couple" can be formally defined as a a <b>generic couple</b>.
- The previous observation poses <b>difficulties into devising an actual implementation</b> of a data structure to represent the domain, since the bit vector used in the optmization tasks undertaken thus far has a defined length, while the set of all possible couples has not.
- <b>Statement.</b> At any point of the algorithm, for any identified variable only a single couple can be propagated, otherwise the value of the variable wouldn't be a precise constant for definition. <br> <b>Proof</b>. A block can only generate a couple for a constant x if it's defining x, and an instruction cannot define more than one variabile; if the block is generating a couple for x, it cannot be propagating any other couple for x, since the definition has killed all other couples for that variable; instead if the block is not generating a couple for x but it is propagating it, that couple it must have been generated by a preceding block, any block can only generate a couple for the variable x and the meet operator intersection ensures that only a single couple for x is being propagated. The same can be applied for a single instruction in a block.
- Thanks to the previous statement a way can be devised to <b>use a bit vector to represent the flow of data of the domain during the execution of the algorithm</b>: the number n of variables present in the code can be statically determined, so a bit vector of n positions can be built after domain determination; for every point p of the code under analysis, the value of the bits indicates if the correspondant variable is considerable constant at that point or not; for every point p, the unique constant value of the variables, if present, is stored in an <b>additional data structure</b>, like a table

\ | line 1 | line 2 | line 3 | ... | line m
--- | --- | --- | --- | --- | ---
var x | val 1 | val 2 | val 3| ... | val p
var y | val p+1 | val p+2 | val p+3| ... | val q
... | ...| ... | ... | ... | ... 
var z | val r+1 | val r+2 | val r+3 | ... | val s

- With this kind of implementation, the algorithm needs a <b>specific procedure to implement unions and intersections</b>. The union between the couple generated in a point p of the code and the couples propagated by point p-1 (or the end-point of a previous block) and the intersection of the couples generated by two blocks operate respectively a bit-a-bit OR and a bit-a-bit AND on the bit vectors relattive to the point interested; however, the additional table must also be visited to retrieve the actual constant values of the variables with bit value 1 at the points under analysis, and these constant value must be taken into consideration since a variable with a bit value of 1 but different constant values in the two points is not considerable the same entity (so an intersection would discard both entitites, while it has been shown that an union will never be in a situation where two instances of the same variable exist); in the end of the operation, in case a couple (var, const_val) is registered for the current point, its value must be stored in the appropriate position in the table.

<br>E.g. block A and block B have a forward edge to block C, so when determining block C "in" flow a merge of A and B "out" flows must be done; the intersection between the two sets of couples (var, const_val) relative to blocks A and B "outs" is done by executing a bit-a-bit AND of the two bit vectors, thus identifying the variables for which a couple is present at the two flow points considered, and then by checking concordance of the respective constant values in the table

```
Domain: {(x,CONST),(y,CONST),(z,CONST)}

Allocate a bit vector of length 3 for all 20 lines of code
(position 1 refers to x, 2 refers to y, 3 refers to z)

block A end point = 5
block B end point = 9
block C start point = 10

Intersection of out[A] and out[B]:
    point5-bit-vector && point9-bit-vector = 101 && 100 = 100
    look for the values of variable 1 (x) at lines 5 and 9 in the table T:
```
\ | line 1 | ... | line 5 | ... | line 9 | ... | line 20
--- | --- | --- | --- | --- | --- | --- | ---
var x (index = 1) | - | ... | 10 | ... | 5 | ... | to be determined
... | ...| ... | ... | ... | ... | ... |...

```
    if T[1][5] == T[1][9] then:
        T[1][10] = T[1][5] 
    else:
        point10-bit-vector[1] = 0
        T[1][10] = -
```

<br>
<b>Example</b>

This example of execution of the algorithm won't be referring to a specific implementation of the data structures, but will <b>operate at the highest abstraction level</b>, where the domain and the data flow representation at any point p of the code is a set of couples (var, const_val); based on this, the set operations intersection and union won't require any specific procedure, but will just be mathemical intersections and unions.
<br><br>Notation simplifications<br>
To address the dinamicity associated to the generation of couples in the algorithm, the following simplification will be adopted: the domain will be initiliazed with a "generic couple" (previously define as (var, CONST)) for every variable defined in the code; similarly the kill set defined at a specific flow point will be containing the same generic couples for any variable defined in the block, to indicate that all definitions of that variable propagated to that point have to be killed.
<br>In order to simplify notation even more, <b>the generic couple (var, CONST) will just be denoted with the name of the variable "var"</b>.

<br>
CFG:

![image](/imgs/ConstantPropagation.jpg)

Domain = {a ,b, x, y, k}

Boundary condition and initialization
Flow point | Data representation
--- | ---
out[Entry] | ∅
in[B1] | -
out[B1] | U
in[B2] | -
out[B2] | U
in[B3] | -
out[B3] | U
in[B4] | -
out[B4] | U
in[B5] | -
out[B5] | U
in[B6] | -
out[B6] | U
in[Exit] | -

<br>

<b>Iteration 1</b>
Flow point | Data representation
--- | ---
out[Entry] | ∅
in[B1] | ∅
out[B1] | {(k,2)} ∪ (∅-{k}) = {(k,2)}
in[B2] | {(k,2)}
out[B2] | {(a,<u>k</u>+2),(x,5)} ∪ ({(<u>k,2</u>)} - {a,x}) = {(a,4),(x,5),(k,2)}
in[B3] | {(k,2)}
out[B3] | {(a,<u>k</u>*2),(x,8)} ∪ ({(<u>k,2</u>)} - {a,x}) = {(a,4),(x,8),(k,2)}
in[B4] | out[B2] ∩ out[B3] = {(a,4),(k,2)}
out[B4] | {(k,<u>a</u>)} ∪ ({(<u>a,4</u>),(k,2)} - {k}) = {(k,4),(a,4)}
in[B5] | {(k,4),(a,4)} ∩ U = {(k,4),(a,4)}
out[B5] | {(<u>b,2</u>),(x,<u>a</u>+<u>k</u>),(y,<u>a</u>*<u>b</u>),(k,<u>k</u>+1)} ∪ ({(<u>k,4</u>),(<u>a,4</u>)} - {b,k,x,y}) = {(b,2),(x,8),(y,8),(k,5)} ∪ {(a,4)} = {(a,4),(b,2),(x,8),(y,8)(k,5)} <br> the couple (k,4) is killed by the last instruction in the block, and the generation of the couples (x,8) and (k,5), which relies on the constant value of k, happens before that point
in[B6] | {(a,4),(b,2),(x,8),(y,8),(k,5)}
out[B6] | {(a,4),(b,2),(x,8),(y,8),(k,5)}
in[Exit] | {(a,4),(b,2),(x,8),(y,8),(k,5)}

changes have been registered

<br>

<b>Iteration 2</b>
Flow point | Data representation
--- | ---
out[Entry] | ∅
in[B1] | ∅
out[B1] | {(k,2)}
in[B2] | {(k,2)}
out[B2] | {(a,4),(x,5),(k,2)}
in[B3] | {(k,2)}
out[B3] | {(a,4),(x,8),(k,2)}
in[B4] | {(a,4),(k,2)}
out[B4] | {(k,4),(a,4)}
in[B5] | {(k,4),(a,4)} ∩ {(a,4),(b,2),(x,8),(y,8),(k,5)} = {(a,4)} <br> the cycle incrementing k continuously kills the couple (k,4) that the flow propagates till the while statement; also, the couple (k,5) generated at the first iteration doesn't "survive" in the following; this just represents the fact that when the execution is in the cycle it can't be assumed how many iterations of said cycle have been done, so the value of k can't be considered constant anymore
out[B5] | {(<u>b,2</u>),(y,<u>a</u>*<u>b</u>)} ∪ ({(<u>a,4</u>)} - {b,k,x,y}) = {(b,2),(y,8)} ∪ {(a,4)} = {(a,4),(b,2),(y,8)} <br> the resolution of the couple (x,a+k) to a constant value fails at this iteration, because no couple of the variable k manages to reach this point
in[B6] | {(a,4),(b,2),(y,8)}
out[B6] | {(a,4),(b,2),(y,8)}
in[Exit] | {(a,4),(b,2),(y,8)}

changes have been registered

<br>

<b>Iteration 3</b>
Flow point | Data representation
--- | ---
out[Entry] | ∅
in[B1] | ∅
out[B1] | {(k,2)}
in[B2] | {(k,2)}
out[B2] | {(a,4),(x,5),(k,2)}
in[B3] | {(k,2)}
out[B3] | {(a,4),(x,8),(k,2)}
in[B4] | {(a,4),(k,2)}
out[B4] | {(k,4),(a,4)}
in[B5] | {(k,4),(a,4)} ∩ {(a,4),(b,2),(y,8)} = {(a,4)}
out[B5] | {(a,4),(b,2),(y,8)}
in[B6] | {(a,4),(b,2),(y,8)}
out[B6] | {(a,4),(b,2),(y,8)}
in[Exit] | {(a,4),(b,2),(y,8)}

no changes have been registered

<br>

The algorithm stops here, and the domain final data can de besumed by the values of the "outs" at any point p of the flow in the last iteration.
